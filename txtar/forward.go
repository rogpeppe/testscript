package txtar

import (
	"github.com/rogpeppe/go-internal/txtar"
)

// generated by goforward github.com/rogpeppe/go-internal/txtar github.com/rogpeppe/testscript/txtar

// An Archive is a collection of files.
type Archive = txtar.Archive

// A File is a single file in an archive.
type File = txtar.File

// Format returns the serialized form of an Archive.
// It is assumed that the Archive data structure is well-formed:
// a.Comment and all a.File[i].Data contain no file marker lines,
// and all a.File[i].Name is non-empty.
func Format(a *Archive) []byte {
	return txtar.Format(a)
}

// ParseFile parses the named file as an archive.
func ParseFile(file string) (*Archive, error) {
	return txtar.ParseFile(file)
}

// Parse parses the serialized form of an Archive.
// The returned Archive holds slices of data.
func Parse(data []byte) *Archive {
	return txtar.Parse(data)
}

// NeedsQuote reports whether the given data needs to
// be quoted before it's included as a txtar file.
func NeedsQuote(data []byte) bool {
	return txtar.NeedsQuote(data)
}

// Quote quotes the data so that it can be safely stored in a txtar
// file. This copes with files that contain lines that look like txtar
// separators.
//
// The original data can be recovered with Unquote. It returns an error
// if the data cannot be quoted (for example because it has no final
// newline or it holds unprintable characters)
func Quote(data []byte) ([]byte, error) {
	return txtar.Quote(data)
}

// Unquote unquotes data as quoted by Quote.
func Unquote(data []byte) ([]byte, error) {
	return txtar.Unquote(data)
}

// Write writes each File in an Archive to the given directory, returning any
// errors encountered. An error is also returned in the event a file would be
// written outside of dir.
func Write(a *Archive, dir string) error {
	return txtar.Write(a, dir)
}
